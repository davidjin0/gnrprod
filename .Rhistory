library(pracma)
second_stage <- function(data) {
data <- data %>% mutate(
big_Y_1 = dplyr::lag(big_Y, n = 1, default = NA),
l_1 = dplyr::lag(l, n = 1, default = NA),
k_1 = dplyr::lag(k, n = 1, default = NA),
ll_1 = dplyr::lag(ll, n = 1, default = NA),
kk_1 = dplyr::lag(kk, n = 1, default = NA),
lk_1 = dplyr::lag(lk, n = 1, default = NA),
big_Y_2 = dplyr::lag(big_Y_1, n = 1, default = NA),
l_2 = dplyr::lag(l_1, n = 1, default = NA),
k_2 = dplyr::lag(k_1, n = 1, default = NA),
ll_2 = dplyr::lag(ll_1, n = 1, default = NA),
kk_2 = dplyr::lag(kk_1, n = 1, default = NA),
lk_2 = dplyr::lag(lk_1, n = 1, default = NA)
)
constant_reg <- lm(big_Y ~ l + k + ll + kk + lk, data = data)
coefficients <- (as.matrix(coef(constant_reg)))[2:6, ]
al <- as.numeric(coefficients[1])
ak <- as.numeric(coefficients[2])
al2 <- as.numeric(coefficients[3])
ak2 <- as.numeric(coefficients[4])
alk <- as.numeric(coefficients[5])
df_gmm <- complete_obs(data, c("big_Y", "l", "k", "big_Y_1", "l_1", "k_1"))
return(df_gmm)
df_gmm <- df_gmm %>% select(
big_Y, l, k, ll, kk, lk, big_Y_1, l_1, k_1, ll_1, kk_1, lk_1
)
constant_gmm <- gaussNewton(x0 = c(al, ak, al2, ak2, alk), data = df_gmm,
Ffun = constant_moments)
C_coef = constant_gmm$xs
data <- data %>% mutate(
logomega = big_Y - (C_coef[1] * l) - (C_coef[2] * k) - (C_coef[3] * ll) -
(C_coef[4] * kk) - (C_coef[5] * lk),
omega = exp(logomega),
prod = exp(logomega + errors),
l_elas = (gl * i + 2 * gll * li + glk * ki) + (gli * ii / 2) + (glki * ki * i/2)
+ C_coef[1] + (2 * C_coef[3] * l) + (C_coef[5] * k),
k_elas = (gk * i + 2 * gkk * ki + glk * li) + (gki * ii / 2) + (glki * li * i/2)
+ C_coef[2] + (2 * C_coef[4] * k) + (C_coef[5] * l)
)
mean_lelas <- mean(data$l_elas, na.rm = T)
mean_kelas <- mean(data$k_elas, na.rm = T)
mean_ielas <- mean(data$i_elas, na.rm = T)
mean_sum_elas = mean(data$l_elas + data$k_elas + data$i_elas, na.rm = T)
mean_l_k_elas = mean_kelas / mean_lelas
point_estimates <- c(mean_lelas, mean_kelas, mean_ielas, mean_sum_elas,
mean_l_k_elas)
return(point_estimates)
}
completeFun <- function(data, desiredCols) {
completeVec <- complete.cases(data[, desiredCols])
return(data[completeVec, ])
}
constant_moments <- function(C_kl, data) {
data <- data %>% mutate(
w = big_Y - {C_kl[1] * l} - {C_kl[2] * k} - {C_kl[3] * ll} - {C_kl[4] * kk} - {C_kl[5] * lk},
w_1 = big_Y_1 - {C_kl[1] * l_1} - {C_kl[2] * k_1} - {C_kl[3] * ll_1} - {C_kl[4] * kk_1} - {C_kl[5] * lk_1},
w2_1 = w_1 * w_1,
w3_1 = w_1 * w_1 * w_1
)
reg <- stats::lm(w ~ w_1 + w2_1 + w3_1, data)
data$csi <- data$w - predict(reg, data)
m1 <- sum(data$l * data$csi) / nrow(data)
m2 <- sum(data$k * data$csi) / nrow(data)
m3 <- sum(data$ll * data$csi) / nrow(data)
m4 <- sum(data$kk * data$csi) / nrow(data)
m5 <- sum(data$lk * data$csi) / nrow(data)
M <- c(m1, m2, m3, m4, m5)
return(M)
}
data = read_dta('data_col.dta')
firststage <- first_stage(RGO ~ L + K + RI, data)
secondstage <- second_stage(firststage)
library(tidyverse)
library(haven)
library(pracma)
second_stage <- function(data) {
data <- data %>% mutate(
big_Y_1 = dplyr::lag(big_Y, n = 1, default = NA),
l_1 = dplyr::lag(l, n = 1, default = NA),
k_1 = dplyr::lag(k, n = 1, default = NA),
ll_1 = dplyr::lag(ll, n = 1, default = NA),
kk_1 = dplyr::lag(kk, n = 1, default = NA),
lk_1 = dplyr::lag(lk, n = 1, default = NA),
big_Y_2 = dplyr::lag(big_Y_1, n = 1, default = NA),
l_2 = dplyr::lag(l_1, n = 1, default = NA),
k_2 = dplyr::lag(k_1, n = 1, default = NA),
ll_2 = dplyr::lag(ll_1, n = 1, default = NA),
kk_2 = dplyr::lag(kk_1, n = 1, default = NA),
lk_2 = dplyr::lag(lk_1, n = 1, default = NA)
)
constant_reg <- lm(big_Y ~ l + k + ll + kk + lk, data = data)
coefficients <- (as.matrix(coef(constant_reg)))[2:6, ]
al <- as.numeric(coefficients[1])
ak <- as.numeric(coefficients[2])
al2 <- as.numeric(coefficients[3])
ak2 <- as.numeric(coefficients[4])
alk <- as.numeric(coefficients[5])
df_gmm <- completeFun(data, c("big_Y", "l", "k", "big_Y_1", "l_1", "k_1"))
return(df_gmm)
df_gmm <- df_gmm %>% select(
big_Y, l, k, ll, kk, lk, big_Y_1, l_1, k_1, ll_1, kk_1, lk_1
)
constant_gmm <- gaussNewton(x0 = c(al, ak, al2, ak2, alk), data = df_gmm,
Ffun = constant_moments)
C_coef = constant_gmm$xs
data <- data %>% mutate(
logomega = big_Y - (C_coef[1] * l) - (C_coef[2] * k) - (C_coef[3] * ll) -
(C_coef[4] * kk) - (C_coef[5] * lk),
omega = exp(logomega),
prod = exp(logomega + errors),
l_elas = (gl * i + 2 * gll * li + glk * ki) + (gli * ii / 2) + (glki * ki * i/2)
+ C_coef[1] + (2 * C_coef[3] * l) + (C_coef[5] * k),
k_elas = (gk * i + 2 * gkk * ki + glk * li) + (gki * ii / 2) + (glki * li * i/2)
+ C_coef[2] + (2 * C_coef[4] * k) + (C_coef[5] * l)
)
mean_lelas <- mean(data$l_elas, na.rm = T)
mean_kelas <- mean(data$k_elas, na.rm = T)
mean_ielas <- mean(data$i_elas, na.rm = T)
mean_sum_elas = mean(data$l_elas + data$k_elas + data$i_elas, na.rm = T)
mean_l_k_elas = mean_kelas / mean_lelas
point_estimates <- c(mean_lelas, mean_kelas, mean_ielas, mean_sum_elas,
mean_l_k_elas)
return(point_estimates)
}
completeFun <- function(data, desiredCols) {
completeVec <- complete.cases(data[, desiredCols])
return(data[completeVec, ])
}
constant_moments <- function(C_kl, data) {
data <- data %>% mutate(
w = big_Y - {C_kl[1] * l} - {C_kl[2] * k} - {C_kl[3] * ll} - {C_kl[4] * kk} - {C_kl[5] * lk},
w_1 = big_Y_1 - {C_kl[1] * l_1} - {C_kl[2] * k_1} - {C_kl[3] * ll_1} - {C_kl[4] * kk_1} - {C_kl[5] * lk_1},
w2_1 = w_1 * w_1,
w3_1 = w_1 * w_1 * w_1
)
reg <- stats::lm(w ~ w_1 + w2_1 + w3_1, data)
data$csi <- data$w - predict(reg, data)
m1 <- sum(data$l * data$csi) / nrow(data)
m2 <- sum(data$k * data$csi) / nrow(data)
m3 <- sum(data$ll * data$csi) / nrow(data)
m4 <- sum(data$kk * data$csi) / nrow(data)
m5 <- sum(data$lk * data$csi) / nrow(data)
M <- c(m1, m2, m3, m4, m5)
return(M)
}
data = read_dta('data_col.dta')
firststage <- first_stage(RGO ~ L + K + RI, data)
secondstage <- second_stage(firststage)
library(tidyverse)
library(haven)
library(pracma)
second_stage <- function(data) {
data <- data %>% mutate(
big_Y_1 = dplyr::lag(big_Y, n = 1, default = NA),
l_1 = dplyr::lag(l, n = 1, default = NA),
k_1 = dplyr::lag(k, n = 1, default = NA),
ll_1 = dplyr::lag(ll, n = 1, default = NA),
kk_1 = dplyr::lag(kk, n = 1, default = NA),
lk_1 = dplyr::lag(lk, n = 1, default = NA),
big_Y_2 = dplyr::lag(big_Y_1, n = 1, default = NA),
l_2 = dplyr::lag(l_1, n = 1, default = NA),
k_2 = dplyr::lag(k_1, n = 1, default = NA),
ll_2 = dplyr::lag(ll_1, n = 1, default = NA),
kk_2 = dplyr::lag(kk_1, n = 1, default = NA),
lk_2 = dplyr::lag(lk_1, n = 1, default = NA)
)
constant_reg <- lm(big_Y ~ l + k + ll + kk + lk, data = data)
coefficients <- (as.matrix(coef(constant_reg)))[2:6, ]
al <- as.numeric(coefficients[1])
ak <- as.numeric(coefficients[2])
al2 <- as.numeric(coefficients[3])
ak2 <- as.numeric(coefficients[4])
alk <- as.numeric(coefficients[5])
df_gmm <- complete_obs(data, c("big_Y", "l", "k", "big_Y_1", "l_1", "k_1"))
df_gmm <- df_gmm %>% select(
big_Y, l, k, ll, kk, lk, big_Y_1, l_1, k_1, ll_1, kk_1, lk_1
)
return(df_gmm)
constant_gmm <- gaussNewton(x0 = c(al, ak, al2, ak2, alk), data = df_gmm,
Ffun = constant_moments)
C_coef = constant_gmm$xs
data <- data %>% mutate(
logomega = big_Y - (C_coef[1] * l) - (C_coef[2] * k) - (C_coef[3] * ll) -
(C_coef[4] * kk) - (C_coef[5] * lk),
omega = exp(logomega),
prod = exp(logomega + errors),
l_elas = (gl * i + 2 * gll * li + glk * ki) + (gli * ii / 2) + (glki * ki * i/2)
+ C_coef[1] + (2 * C_coef[3] * l) + (C_coef[5] * k),
k_elas = (gk * i + 2 * gkk * ki + glk * li) + (gki * ii / 2) + (glki * li * i/2)
+ C_coef[2] + (2 * C_coef[4] * k) + (C_coef[5] * l)
)
mean_lelas <- mean(data$l_elas, na.rm = T)
mean_kelas <- mean(data$k_elas, na.rm = T)
mean_ielas <- mean(data$i_elas, na.rm = T)
mean_sum_elas = mean(data$l_elas + data$k_elas + data$i_elas, na.rm = T)
mean_l_k_elas = mean_kelas / mean_lelas
point_estimates <- c(mean_lelas, mean_kelas, mean_ielas, mean_sum_elas,
mean_l_k_elas)
return(point_estimates)
}
complete_obs <- function(data, cols) {
complete_vectors <- complete.cases(data[, cols])
return(data[complete_vectors, ])
}
constant_moments <- function(C_kl, data) {
data <- data %>% mutate(
w = big_Y - {C_kl[1] * l} - {C_kl[2] * k} - {C_kl[3] * ll} - {C_kl[4] * kk} - {C_kl[5] * lk},
w_1 = big_Y_1 - {C_kl[1] * l_1} - {C_kl[2] * k_1} - {C_kl[3] * ll_1} - {C_kl[4] * kk_1} - {C_kl[5] * lk_1},
w2_1 = w_1 * w_1,
w3_1 = w_1 * w_1 * w_1
)
reg <- stats::lm(w ~ w_1 + w2_1 + w3_1, data)
data$csi <- data$w - predict(reg, data)
m1 <- sum(data$l * data$csi) / nrow(data)
m2 <- sum(data$k * data$csi) / nrow(data)
m3 <- sum(data$ll * data$csi) / nrow(data)
m4 <- sum(data$kk * data$csi) / nrow(data)
m5 <- sum(data$lk * data$csi) / nrow(data)
M <- c(m1, m2, m3, m4, m5)
return(M)
}
data = read_dta('data_col.dta')
firststage <- first_stage(RGO ~ L + K + RI, data)
secondstage <- second_stage(firststage)
apply(secondstage, 2, function(x) any(is.na(x)))
View(data)
View(firststage)
library(tidyverse)
library(haven)
library(pracma)
second_stage <- function(data) {
data <- data %>% mutate(
big_Y_1 = dplyr::lag(big_Y, n = 1, default = NA),
l_1 = dplyr::lag(l, n = 1, default = NA),
k_1 = dplyr::lag(k, n = 1, default = NA),
ll_1 = dplyr::lag(ll, n = 1, default = NA),
kk_1 = dplyr::lag(kk, n = 1, default = NA),
lk_1 = dplyr::lag(lk, n = 1, default = NA),
big_Y_2 = dplyr::lag(big_Y_1, n = 1, default = NA),
l_2 = dplyr::lag(l_1, n = 1, default = NA),
k_2 = dplyr::lag(k_1, n = 1, default = NA),
ll_2 = dplyr::lag(ll_1, n = 1, default = NA),
kk_2 = dplyr::lag(kk_1, n = 1, default = NA),
lk_2 = dplyr::lag(lk_1, n = 1, default = NA)
)
constant_reg <- lm(big_Y ~ l + k + ll + kk + lk, data = data)
coefficients <- (as.matrix(coef(constant_reg)))[2:6, ]
al <- as.numeric(coefficients[1])
ak <- as.numeric(coefficients[2])
al2 <- as.numeric(coefficients[3])
ak2 <- as.numeric(coefficients[4])
alk <- as.numeric(coefficients[5])
df_gmm <- complete_obs(data, cols = c("big_Y", "l", "k", "big_Y_1", "l_1", "k_1"))
df_gmm <- df_gmm %>% select(
big_Y, l, k, ll, kk, lk, big_Y_1, l_1, k_1, ll_1, kk_1, lk_1
)
return(df_gmm)
constant_gmm <- gaussNewton(x0 = c(al, ak, al2, ak2, alk), data = df_gmm,
Ffun = constant_moments)
C_coef = constant_gmm$xs
data <- data %>% mutate(
logomega = big_Y - (C_coef[1] * l) - (C_coef[2] * k) - (C_coef[3] * ll) -
(C_coef[4] * kk) - (C_coef[5] * lk),
omega = exp(logomega),
prod = exp(logomega + errors),
l_elas = (gl * i + 2 * gll * li + glk * ki) + (gli * ii / 2) + (glki * ki * i/2)
+ C_coef[1] + (2 * C_coef[3] * l) + (C_coef[5] * k),
k_elas = (gk * i + 2 * gkk * ki + glk * li) + (gki * ii / 2) + (glki * li * i/2)
+ C_coef[2] + (2 * C_coef[4] * k) + (C_coef[5] * l)
)
mean_lelas <- mean(data$l_elas, na.rm = T)
mean_kelas <- mean(data$k_elas, na.rm = T)
mean_ielas <- mean(data$i_elas, na.rm = T)
mean_sum_elas = mean(data$l_elas + data$k_elas + data$i_elas, na.rm = T)
mean_l_k_elas = mean_kelas / mean_lelas
point_estimates <- c(mean_lelas, mean_kelas, mean_ielas, mean_sum_elas,
mean_l_k_elas)
return(point_estimates)
}
complete_obs <- function(data, cols) {
complete_vectors <- complete.cases(data[, cols])
return(data[complete_vectors, ])
}
constant_moments <- function(C_kl, data) {
data <- data %>% mutate(
w = big_Y - {C_kl[1] * l} - {C_kl[2] * k} - {C_kl[3] * ll} - {C_kl[4] * kk} - {C_kl[5] * lk},
w_1 = big_Y_1 - {C_kl[1] * l_1} - {C_kl[2] * k_1} - {C_kl[3] * ll_1} - {C_kl[4] * kk_1} - {C_kl[5] * lk_1},
w2_1 = w_1 * w_1,
w3_1 = w_1 * w_1 * w_1
)
reg <- stats::lm(w ~ w_1 + w2_1 + w3_1, data)
data$csi <- data$w - predict(reg, data)
m1 <- sum(data$l * data$csi) / nrow(data)
m2 <- sum(data$k * data$csi) / nrow(data)
m3 <- sum(data$ll * data$csi) / nrow(data)
m4 <- sum(data$kk * data$csi) / nrow(data)
m5 <- sum(data$lk * data$csi) / nrow(data)
M <- c(m1, m2, m3, m4, m5)
return(M)
}
data = read_dta('data_col.dta')
firststage <- first_stage(RGO ~ L + K + RI, data)
secondstage <- second_stage(firststage)
View(secondstage)
View(firststage)
apply(firststage, 2, function(x) any(is.na(x)))
library(tidyverse)
library(haven)
library(pracma)
second_stage <- function(data) {
data <- data %>% mutate(
big_Y_1 = dplyr::lag(big_Y, n = 1, default = NA),
l_1 = dplyr::lag(l, n = 1, default = NA),
k_1 = dplyr::lag(k, n = 1, default = NA),
ll_1 = dplyr::lag(ll, n = 1, default = NA),
kk_1 = dplyr::lag(kk, n = 1, default = NA),
lk_1 = dplyr::lag(lk, n = 1, default = NA),
big_Y_2 = dplyr::lag(big_Y_1, n = 1, default = NA),
l_2 = dplyr::lag(l_1, n = 1, default = NA),
k_2 = dplyr::lag(k_1, n = 1, default = NA),
ll_2 = dplyr::lag(ll_1, n = 1, default = NA),
kk_2 = dplyr::lag(kk_1, n = 1, default = NA),
lk_2 = dplyr::lag(lk_1, n = 1, default = NA)
)
return(data)
constant_reg <- lm(big_Y ~ l + k + ll + kk + lk, data = data)
coefficients <- (as.matrix(coef(constant_reg)))[2:6, ]
al <- as.numeric(coefficients[1])
ak <- as.numeric(coefficients[2])
al2 <- as.numeric(coefficients[3])
ak2 <- as.numeric(coefficients[4])
alk <- as.numeric(coefficients[5])
df_gmm <- complete_obs(data, cols = c("big_Y", "l", "k", "big_Y_1", "l_1", "k_1"))
df_gmm <- df_gmm %>% select(
big_Y, l, k, ll, kk, lk, big_Y_1, l_1, k_1, ll_1, kk_1, lk_1
)
constant_gmm <- gaussNewton(x0 = c(al, ak, al2, ak2, alk), data = df_gmm,
Ffun = constant_moments)
C_coef = constant_gmm$xs
data <- data %>% mutate(
logomega = big_Y - (C_coef[1] * l) - (C_coef[2] * k) - (C_coef[3] * ll) -
(C_coef[4] * kk) - (C_coef[5] * lk),
omega = exp(logomega),
prod = exp(logomega + errors),
l_elas = (gl * i + 2 * gll * li + glk * ki) + (gli * ii / 2) + (glki * ki * i/2)
+ C_coef[1] + (2 * C_coef[3] * l) + (C_coef[5] * k),
k_elas = (gk * i + 2 * gkk * ki + glk * li) + (gki * ii / 2) + (glki * li * i/2)
+ C_coef[2] + (2 * C_coef[4] * k) + (C_coef[5] * l)
)
mean_lelas <- mean(data$l_elas, na.rm = T)
mean_kelas <- mean(data$k_elas, na.rm = T)
mean_ielas <- mean(data$i_elas, na.rm = T)
mean_sum_elas = mean(data$l_elas + data$k_elas + data$i_elas, na.rm = T)
mean_l_k_elas = mean_kelas / mean_lelas
point_estimates <- c(mean_lelas, mean_kelas, mean_ielas, mean_sum_elas,
mean_l_k_elas)
return(point_estimates)
}
complete_obs <- function(data, cols) {
complete_vectors <- complete.cases(data[, cols])
return(data[complete_vectors, ])
}
constant_moments <- function(C_kl, data) {
data <- data %>% mutate(
w = big_Y - {C_kl[1] * l} - {C_kl[2] * k} - {C_kl[3] * ll} - {C_kl[4] * kk} - {C_kl[5] * lk},
w_1 = big_Y_1 - {C_kl[1] * l_1} - {C_kl[2] * k_1} - {C_kl[3] * ll_1} - {C_kl[4] * kk_1} - {C_kl[5] * lk_1},
w2_1 = w_1 * w_1,
w3_1 = w_1 * w_1 * w_1
)
reg <- stats::lm(w ~ w_1 + w2_1 + w3_1, data)
data$csi <- data$w - predict(reg, data)
m1 <- sum(data$l * data$csi) / nrow(data)
m2 <- sum(data$k * data$csi) / nrow(data)
m3 <- sum(data$ll * data$csi) / nrow(data)
m4 <- sum(data$kk * data$csi) / nrow(data)
m5 <- sum(data$lk * data$csi) / nrow(data)
M <- c(m1, m2, m3, m4, m5)
return(M)
}
data = read_dta('data_col.dta')
firststage <- first_stage(RGO ~ L + K + RI, data)
secondstage <- second_stage(firststage)
apply(secondstage, 2, function(x) any(is.na(x)))
View(secondstage)
df_gmm <- complete_obs(data, cols = c("big_Y", "l", "k", "big_Y_1", "l_1", "k_1"))
library(tidyverse)
library(haven)
library(pracma)
second_stage <- function(data) {
data <- data %>% mutate(
big_Y_1 = dplyr::lag(big_Y, n = 1, default = NA),
l_1 = dplyr::lag(l, n = 1, default = NA),
k_1 = dplyr::lag(k, n = 1, default = NA),
ll_1 = dplyr::lag(ll, n = 1, default = NA),
kk_1 = dplyr::lag(kk, n = 1, default = NA),
lk_1 = dplyr::lag(lk, n = 1, default = NA),
big_Y_2 = dplyr::lag(big_Y_1, n = 1, default = NA),
l_2 = dplyr::lag(l_1, n = 1, default = NA),
k_2 = dplyr::lag(k_1, n = 1, default = NA),
ll_2 = dplyr::lag(ll_1, n = 1, default = NA),
kk_2 = dplyr::lag(kk_1, n = 1, default = NA),
lk_2 = dplyr::lag(lk_1, n = 1, default = NA)
)
constant_reg <- lm(big_Y ~ l + k + ll + kk + lk, data = data)
coefficients <- (as.matrix(coef(constant_reg)))[2:6, ]
al <- as.numeric(coefficients[1])
ak <- as.numeric(coefficients[2])
al2 <- as.numeric(coefficients[3])
ak2 <- as.numeric(coefficients[4])
alk <- as.numeric(coefficients[5])
df_gmm <- complete_obs(data, cols = c("big_Y", "l", "k", "big_Y_1", "l_1", "k_1"))
return(df_gmm)
df_gmm <- df_gmm %>% select(
big_Y, l, k, ll, kk, lk, big_Y_1, l_1, k_1, ll_1, kk_1, lk_1
)
constant_gmm <- gaussNewton(x0 = c(al, ak, al2, ak2, alk), data = df_gmm,
Ffun = constant_moments)
C_coef = constant_gmm$xs
data <- data %>% mutate(
logomega = big_Y - (C_coef[1] * l) - (C_coef[2] * k) - (C_coef[3] * ll) -
(C_coef[4] * kk) - (C_coef[5] * lk),
omega = exp(logomega),
prod = exp(logomega + errors),
l_elas = (gl * i + 2 * gll * li + glk * ki) + (gli * ii / 2) + (glki * ki * i/2)
+ C_coef[1] + (2 * C_coef[3] * l) + (C_coef[5] * k),
k_elas = (gk * i + 2 * gkk * ki + glk * li) + (gki * ii / 2) + (glki * li * i/2)
+ C_coef[2] + (2 * C_coef[4] * k) + (C_coef[5] * l)
)
mean_lelas <- mean(data$l_elas, na.rm = T)
mean_kelas <- mean(data$k_elas, na.rm = T)
mean_ielas <- mean(data$i_elas, na.rm = T)
mean_sum_elas = mean(data$l_elas + data$k_elas + data$i_elas, na.rm = T)
mean_l_k_elas = mean_kelas / mean_lelas
point_estimates <- c(mean_lelas, mean_kelas, mean_ielas, mean_sum_elas,
mean_l_k_elas)
return(point_estimates)
}
complete_obs <- function(data, cols) {
complete_vectors <- complete.cases(data[, cols])
return(data[complete_vectors, ])
}
constant_moments <- function(C_kl, data) {
data <- data %>% mutate(
w = big_Y - {C_kl[1] * l} - {C_kl[2] * k} - {C_kl[3] * ll} - {C_kl[4] * kk} - {C_kl[5] * lk},
w_1 = big_Y_1 - {C_kl[1] * l_1} - {C_kl[2] * k_1} - {C_kl[3] * ll_1} - {C_kl[4] * kk_1} - {C_kl[5] * lk_1},
w2_1 = w_1 * w_1,
w3_1 = w_1 * w_1 * w_1
)
reg <- stats::lm(w ~ w_1 + w2_1 + w3_1, data)
data$csi <- data$w - predict(reg, data)
m1 <- sum(data$l * data$csi) / nrow(data)
m2 <- sum(data$k * data$csi) / nrow(data)
m3 <- sum(data$ll * data$csi) / nrow(data)
m4 <- sum(data$kk * data$csi) / nrow(data)
m5 <- sum(data$lk * data$csi) / nrow(data)
M <- c(m1, m2, m3, m4, m5)
return(M)
}
data = read_dta('data_col.dta')
firststage <- first_stage(RGO ~ L + K + RI, data)
secondstage <- second_stage(firststage)
View(data)
organize <- function(formula, id, time, data) {
data <- data %>% group_by(toString(id))
return(data)
vars = all.vars(formula)
y <- (log(data[, vars[1]]))[, 1]
l <- (log(data[, vars[2]]))[, 1]
k <- (log(data[, vars[3]]))[, 1]
i <- (log(data[, vars[4]]))[, 1]
# Theorem 2 assumes access to rho/P (relative price deflator). Is it
# reasonable to assume that the user has these parameters? Should we add
# an option so that the user can add them? For now I set them to 1.
rho = 1
P = 1
# s = ((rho * data[, vars[4]]) / (P * data[, vars[1]]))[, 1]
# s = log(s)
s = data$si
df <- data.frame(y, l, k, i, s)
# How to make it so that function can identify which inputs are flexible?
# maybe add an option: organize(formula, data, intermediates = i)
df <- df %>% rename(
y = vars[1],
l = vars[2],
k = vars[3],
i = vars[4]
)
df <- df %>% mutate(
ll = l * l,
kk = k * k,
ii = i * i,
lk = l * k,
li = l * i,
ki = k * i,
lki = l * k * i
)
df <- na.omit(df)
return(df)
}
evaluate <- function(start, data) {
value <- start[1] + (start[2] * data$l) + (start[3] * data$k) +
(start[4] * data$i) + (start[5] * data$ll) + (start[6] * data$lk) +
(start[7] * data$li) + (start[8] * data$kk) + (start[9] * data$ki) +
(start[10] * data$ii) + (start[11] * data$lki)
return(value)
}
formula = RGO ~ L + K + RI
data = read_dta('data_col.dta')
organized = organize(formula, id, time, data)
View(organized)
