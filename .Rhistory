idm <- as.matrix(data[, id])
id_name <- id
} else {
idm <- as.matrix(id)
id_name <- colnames(id)
if (is.null(id_name)) {
id_name <- deparse(substitute(id))
}
}
if (is.character(time)) {
timem <- as.matrix(data[, time])
time_name <- time
} else {
timem <- as.matrix(timem)
time_name <- colnames(time)
if (is.null(time_name)) {
time_name <- deparse(substitute(time))
}
}
if (!missing(share) && is.character(share)) {
sharem <- as.matrix(log(data[, share]))
share_name <- share
} else if (!missing(share) && !is.character(share)) {
sharem <- as.matrix(log(share))
share_name <- colnames(share)
if (is.null(share_name)) {
share_name <- deparse(substitute(share))
}
} else if (!missing(in_price) && !missing(out_price)) {
if (is.character(in_price)) {
in_pricem <- as.matrix(data[, in_price])
} else {
in_pricem <- as.matrix(in_price)
}
if (is.character(out_price)) {
out_pricem <- as.matrix(data[, out_price])
} else {
out_pricem <- as.matrix(out_price)
}
sharem = as.matrix(log((in_price * flex_input) / (out_price * y)))
share_name = "share"
} else {
stop("must specify either share or intermediate-input price and output price")
}
complete_obs <- stats::complete.cases(cbind(y, fixed_input, flex_input, idm,
timem, sharem))
y <- y[complete_obs]
fixed_input <- data.frame(fixed_input[complete_obs, ])
flex_input <- data.frame(flex_input[complete_obs])
idm <- idm[complete_obs]
timem <- timem[complete_obs]
sharem <- sharem[complete_obs]
gnrflex <- gnr_flex(output = y,
fixed = fixed_input,
flex = flex_input,
share = sharem,
id = idm,
time = timem,
degree = degree,
control = fs_control)
second_stage_list <- second_stage(object = gnrflex, degree = markov_degree,
control = ss_control)
ss_return <- second_stage_list[[2]]
pred_elas <- second_stage_list[[1]]
flex_elas <- gnrflex$elas$flex_in_elas
elas <- data.frame(cbind(pred_elas, flex_elas))
input_names <- c(fixed_name, flex_name)
input_names <- paste(input_names, "elasticity", sep = "_")
colnames(elas) <- input_names
return_df <- data.frame(cbind(y, fixed_input, flex_input, idm, timem, sharem))
colnames(return_df) <- c(output_name, fixed_name, flex_name, id_name,
time_name, share_name)
fs_return <- list("coefficients" = gnrflex$elas$coef,
"residuals" = gnrflex$elas$residuals,
"SSR" = gnrflex$elas$SSR,
"iterations" = gnrflex$elas$iterations,
"convergence" = gnrflex$elas$convergence)
point_estimates <- list("estimates" = elas, "data" = return_df)
return_average_elas <- apply(elas, MARGIN = 2, FUN = mean)
names(return_average_elas) <- paste(input_names, "avg", sep = "_")
gnr_out <- list(return_average_elas, point_estimates,
fs_return, ss_return, cl)
names(gnr_out) <- c("avg_elasticity", "point_estimates", "first_stage",
"second_stage", "call")
class(gnr_out) <- "gnr"
return(gnr_out)
}
industry_311 <- gnrprod(output = "RGO",
fixed = c("L", "K"),
flex = "RI",
share = exp(data$si),
id = "id",
time = "year",
data = data,
degree = 3,
markov_degree = 3)
View(industry_311)
coef.gnr <- function(object) object$avg_elasticity
print.gnr <- function(object, digits = max(3L, getOption("digits") - 3L)) {
cat("Call:\n")
cat("  output: ", deparse(object$call$output), "\n", sep = "")
cat("  fixed inputs: ", deparse(object$call$fixed), "\n", sep = " ")
cat("  flexible inputs: ", deparse(object$call$flex), "\n", sep = " ")
if (!is.null(object$call$data)) {
cat("  data: ", deparse(object$call$data), "\n", sep = "")
}
cat("\n")
cat("Average input elasticities:\n")
print(object$avg_elasticity, digits = digits)
cat("\n")
cat("First stage sum of squared residuals: ", object$first_stage$SSR)
invisible(object)
}
extract.gnr <- function(object) {
do.call(cbind, object$point_estimates)
}
beans <- extract(industry_311)
View(beans)
coef.gnr <- function(object) object$avg_elasticity
print.gnr <- function(object, digits = max(3L, getOption("digits") - 3L)) {
cat("Call:\n")
cat("  output: ", deparse(object$call$output), "\n", sep = "")
cat("  fixed inputs: ", deparse(object$call$fixed), "\n", sep = " ")
cat("  flexible inputs: ", deparse(object$call$flex), "\n", sep = " ")
if (!is.null(object$call$data)) {
cat("  data: ", deparse(object$call$data), "\n", sep = "")
}
cat("\n")
cat("Average input elasticities:\n")
print(object$avg_elasticity, digits = digits)
cat("\n")
cat("First stage sum of squared residuals: ", object$first_stage$SSR)
invisible(object)
}
extract.gnr <- function(object) {
cbind(object$point_estimates$data, object$point_estimates$estimates)
}
beans <- extract(industry_311)
View(beans)
#' Estimate the nonparametric model in two stages: the share regression and instrumental variable estimation
#'
#' @param output name (character) of variable of level gross output or a numeric vector/dataframe/matrix
#' @param fixed name (character or character vector) of variables of level fixed inputs or a numeric vector/dataframe/matrix
#' @param flex name (character) of variable of level flexible input or a numeric vector/dataframe/matrix
#' @param share name (character) of variable of level intermediate input's revenue share or a numeric vector/dataframe/matrix
#' @param in_price optional name (character) of variable of common flexible input price or a numeric vector/dataframe/matrix
#' @param out_price optional name (character) of variable of common output price or a numeric vector/dataframe/matrix
#' @param id name (character) of variable of firm id or a numeric vector/dataframe/matrix
#' @param time name (character) of variable of time or a numeric vector/dataframe/matrix
#' @param data dataframe containing all variables with names specified by arguments above (left empty if arguments above are vector/dataframe/matrix)
#' @param degree degree of share regression polynomial
#' @param markov_degree degree of Markovian process for persistent productivity
#' @param firstStageOnly boolean for whether return is only first stage results
#' @param fs_control list of convergence parameters for first stage
#' @param ss_control list of convergence parameters for second stage
#' @return a list of class "gnr" with five elements:
#' \code{avg_elasticity}: a named numeric vector of the average elasticities of all inputs
#'
#' \code{data}: a list (data frame) containing:\code{output}, \code{fixed}, \code{flex}, \code{id}, \code{time}, and \code{share} variables and individual estimated elasticities
#'
#' \code{first_stage}: a list containing six elements describing the share regression (first stage):
#' \itemize{
#'  \item{\code{coef}}{: a numeric vector of the coefficients}
#'  \item{\code{residuals}}{: a numeric vector of the residuals}
#'  \item{\code{SSR}}{: sum of squared residual}
#'  \item{\code{iterations}}{: number of iterations performed}
#'  \item{\code{convergence}}{: boolean indicating whether convergence was achieved}
#'  \item{\code{control}}{: a list containing information on algorithm convergence (Gauss-Newton)}
#' }
#'
#' \code{second_stage}: a list containing four elements describing the second stage:
#' \itemize{
#'  \item{\code{productivity}}{: a numeric vector of the total productivity of each observations}
#'  \item{\code{iterations}}{: number of iterations performed}
#'  \item{\code{convergence}}{: boolean indicating whether convergence was achieved}
#'  \item{\code{control}}{: a list containing information on algorithm convergence (Gauss-Newton)}
#' }
#'
#' @usage gnrprod(output, fixed, flex, share, in_price = NULL,
#'                out_price = NULL, id, time, data, degree = 2,
#'                markov_degree = 2, firstStageOnly = FALSE,
#'                fs_control = list(), ss_control = list())
#' @export
gnrprod <- function(output, fixed, flex, share, in_price = NULL,
out_price = NULL, id, time, data, degree = 2,
markov_degree = 2, firstStageOnly = FALSE,
fs_control = list(), ss_control = list()) {
cl <- match.call()
if (is.character(output)) {
y <- as.matrix(log(data[, output]))
output_name <- output
} else {
y <- as.matrix(log(output))
output_name <- colnames(output)
if (is.null(output_name)) {
output_name <- deparse(substitute(output))
}
}
if (is.character(fixed)) {
fixed_input <- as.matrix(log(data[, fixed]))
fixed_name <- fixed
} else {
fixed_input <- as.matrix(log(fixed))
fixed_name <- colnames(fixed)
if (is.null(fixed_name)) {
fixed_name <- paste0(deparse(substitute(fixed)), 1L:ncol(fixed))
}
}
if (is.character(flex)) {
flex_input <- as.matrix(log(data[, flex]))
flex_name <- flex
} else {
flex_input <- as.matrix(log(flex))
flex_name <- colnames(flex)
if (is.null(flex_name)) {
flex_name <- deparse(substitute(flex))
}
}
if (is.character(id)) {
idm <- as.matrix(data[, id])
id_name <- id
} else {
idm <- as.matrix(id)
id_name <- colnames(id)
if (is.null(id_name)) {
id_name <- deparse(substitute(id))
}
}
if (is.character(time)) {
timem <- as.matrix(data[, time])
time_name <- time
} else {
timem <- as.matrix(timem)
time_name <- colnames(time)
if (is.null(time_name)) {
time_name <- deparse(substitute(time))
}
}
if (!missing(share) && is.character(share)) {
sharem <- as.matrix(log(data[, share]))
share_name <- share
} else if (!missing(share) && !is.character(share)) {
sharem <- as.matrix(log(share))
share_name <- colnames(share)
if (is.null(share_name)) {
share_name <- deparse(substitute(share))
}
} else if (!missing(in_price) && !missing(out_price)) {
if (is.character(in_price)) {
in_pricem <- as.matrix(data[, in_price])
} else {
in_pricem <- as.matrix(in_price)
}
if (is.character(out_price)) {
out_pricem <- as.matrix(data[, out_price])
} else {
out_pricem <- as.matrix(out_price)
}
sharem = as.matrix(log((in_price * flex_input) / (out_price * y)))
share_name = "share"
} else {
stop("must specify either share or intermediate-input price and output price")
}
complete_obs <- stats::complete.cases(cbind(y, fixed_input, flex_input, idm,
timem, sharem))
y <- y[complete_obs]
fixed_input <- data.frame(fixed_input[complete_obs, ])
flex_input <- data.frame(flex_input[complete_obs])
idm <- idm[complete_obs]
timem <- timem[complete_obs]
sharem <- sharem[complete_obs]
gnrflex <- gnr_flex(output = y,
fixed = fixed_input,
flex = flex_input,
share = sharem,
id = idm,
time = timem,
degree = degree,
control = fs_control)
gnriv <- gnr_iv(object = gnrflex, degree = markov_degree,
control = ss_control)
return(gnriv)
ss_return <- gnriv[[2]]
pred_elas <- gnriv[[1]]
flex_elas <- gnrflex$elas$flex_in_elas
elas <- data.frame(cbind(pred_elas, flex_elas))
input_names <- c(fixed_name, flex_name)
input_names <- paste(input_names, "elasticity", sep = "_")
colnames(elas) <- input_names
return_df <- data.frame(cbind(y, fixed_input, flex_input, idm, timem, sharem))
colnames(return_df) <- c(output_name, fixed_name, flex_name, id_name,
time_name, share_name)
fs_return <- list("coefficients" = gnrflex$elas$coef,
"residuals" = gnrflex$elas$residuals,
"SSR" = gnrflex$elas$SSR,
"iterations" = gnrflex$elas$iterations,
"convergence" = gnrflex$elas$convergence)
point_estimates <- list("estimates" = elas, "data" = return_df)
return_average_elas <- apply(elas, MARGIN = 2, FUN = mean)
names(return_average_elas) <- paste(input_names, "avg", sep = "_")
gnr_out <- list(return_average_elas, point_estimates,
fs_return, ss_return, cl)
names(gnr_out) <- c("avg_elasticity", "point_estimates", "first_stage",
"second_stage", "call")
class(gnr_out) <- "gnr"
return(gnr_out)
}
gnr_flex <- function(output, fixed, flex, share, id, time, degree, control) {
all_input = as.matrix(cbind(fixed, flex))
poly_input = as.matrix(stats::poly(all_input, degree = degree, raw = TRUE))
input_degrees <- sapply(colnames(poly_input), FUN = function(x) {
a <- data.frame(base::strsplit(x, split = "[.]")[[1]])
})
input_degrees <- data.frame(do.call(cbind, input_degrees))
input_degrees <- sapply(input_degrees, as.numeric)
gamma_denom <- rbind(1, matrix(input_degrees[nrow(input_degrees), ] + 1))
start_reg <- stats::lm(share ~ poly_input)
constant <- start_reg$fitted.values - stats::coef(start_reg)[1]
constant <- -min(constant, na.rm = T) + 0.1
start <- c(constant, (coef(start_reg)[-1]))
share_reg <- gauss_newton_reg(start = start, data = poly_input, share = share,
control = control)
coef = share_reg[[1]]
i_elas = log(evaluate_gnr(coef, poly_input))
errors = i_elas - share
mean_exp_err = mean(exp(errors))
i_elas = exp(i_elas - log(mean_exp_err))
gamma <- as.matrix(coef / mean_exp_err)
flex_gamma <- gamma / gamma_denom
integ_G_I = evaluate_gnr(flex_gamma, poly_input)
integ_G_I = integ_G_I * flex
big_Y = as.matrix(output - errors - integ_G_I)
fs_elas <- list("flex_in_elas" = i_elas,
"coef" = coef,
"residuals" = errors,
"SSR" = share_reg$SSR,
"iterations" = share_reg$iterations,
"convergence" = share_reg$convergence)
fs_arg <- list("input" = poly_input,
"input_degree" = input_degrees,
"big_Y" = big_Y,
"gamma" = gamma,
"gamma_denom" = gamma_denom,
"id" = id,
"time" = time,
"degree" = degree)
fs_return <- list("elas" = fs_elas, "arg" = fs_arg)
class(fs_return) <- "gnrflex"
return(fs_return)
}
gauss_newton_reg <- function(start, data, share, control) {
ctrl <- do.call("fs_control", control)
if (!missing(control)) {
control <- as.list(control)
ctrl[names(control)] <- control
}
iter <- 0
call_start <- start
inputs_1 = data.frame(rep(1, nrow(data)), data)
names(inputs_1)[1] <- "constant"
while (iter < ctrl$maxit) {
initial_pred <- evaluate_gnr(call_start, data)
X <- as.matrix(inputs_1 / initial_pred)
initial_errors <- as.matrix(cbind(share - log(initial_pred)))
initial_SSR <- t(initial_errors) %*% initial_errors
new_start <- call_start + (solve(t(X) %*% X) %*% t(X) %*% initial_errors)
new_pred <- evaluate_gnr(new_start, data)
suppressWarnings(new_errors <- cbind(share - log(new_pred)))
new_SSR <- t(new_errors) %*% new_errors
initial_step = ctrl$initial_step
min_factor = ctrl$min_factor
while ((is.na(new_SSR) || new_SSR > initial_SSR)
& initial_step >= min_factor) {
initial_step <- initial_step / 2
new_start <- call_start +
initial_step * (solve(t(X) %*% X) %*% t(X) %*% initial_errors)
new_pred <- evaluate_gnr(new_start, data)
suppressWarnings(new_errors <- cbind(share - log(new_pred)))
new_SSR = t(new_errors) %*% new_errors
}
conv_bool <- TRUE
for (i in 1:length(new_start)) {
if (initial_step * abs(new_start[i]) > ctrl$reltol *
(abs(new_start[i]) + 1e-3)) {
conv_bool <- FALSE
break
}
}
iter = iter + 1
if (conv_bool) {
return_list <- list(new_start, iter, new_SSR, conv_bool)
names(return_list) <- c("share_reg_coef", "iterations", "SSR",
"convergence")
return(return_list)
}
call_start = new_start
}
warning("share regression failed to converge")
return_list <- list(new_start, iter, new_SSR, conv_bool)
names(return_list) <- c("share_reg_coef", "iterations", "SSR", "convergence")
return(return_list)
}
evaluate_gnr <- function(start, data) {
matrix = as.matrix(cbind(rep(1, nrow(data)), data))
new_m = matrix %*% start
return(new_m)
}
gnr_iv <- function(object, degree, control) {
if (attr(object, "class") != "gnrflex") {
stop("object must be of class gnrflex")
}
in_df <- data.frame(rbind(object$arg$input, object$arg$input_degree))
pred <- in_df[, in_df[nrow(in_df), ] == 0]
pred <- pred[-c((nrow(pred) -
(nrow(object$arg$input_degree) - 1)):(nrow(pred))), ]
flex <- in_df[, in_df[nrow(in_df), ] != 0]
flex <- flex[-c((nrow(flex) -
(nrow(object$arg$input_degree) - 1)):(nrow(flex))), ]
id <- object$arg$id
time <- object$arg$time
big_Y <- object$arg$big_Y
errors <- object$elas$residuals
constant_reg <- stats::lm(big_Y ~ as.matrix(pred))
coefficients <- stats::coef(constant_reg)[2:(ncol(pred) + 1)]
ss_df <- data.frame(cbind(id, time, pred, big_Y))
ss_df <- lag_gnr(ss_df)
pred_base <- as.matrix(ss_df[[1]])
big_Y_base <- pred_base[, ncol(pred_base)]
pred_base <- pred_base[, -c(ncol(pred_base))]
pred_lag <- as.matrix(ss_df[[2]])
big_Y_lag <- pred_lag[, ncol(pred_lag)]
pred_lag <- pred_lag[, -c(ncol(pred_lag))]
ctrl <- do.call("ss_control", control)
if (!missing(control)) {
control <- as.list(control)
ctrl[names(control)] <- control
}
constant_gmm <- pracma::gaussNewton(x0 = coefficients, data = pred_base,
Ffun = constant_moments,
big_Y_base = big_Y_base,
big_Y_lag = big_Y_lag,
lag_data = pred_lag,
degree = degree,
maxiter = ctrl$maxit,
tol = ctrl$reltol)
convergence <- ifelse(constant_gmm$niter >= ctrl$maxit, FALSE, TRUE)
C_coef <- constant_gmm$xs
input_degree <- object$arg$input_degree
all_input <- object$arg$input
gamma <- object$arg$gamma[-1, ]
gamma_denom <- object$arg$gamma_denom[-1, ]
elasticities <- lapply(1:(nrow(input_degree) - 1), FUN = function(i) {
new_in_deg <- input_degree
new_in_deg[i, ] <- ifelse(new_in_deg[i, ] > 0,
new_in_deg[i, ] - 1,
new_in_deg[i, ])
new_C_deg <- new_in_deg[, new_in_deg[nrow(input_degree), ] == 0]
new_in_deg[nrow(new_in_deg), ] <- new_in_deg[nrow(new_in_deg), ] + 1
in_match <- apply(new_in_deg, MARGIN = 2, FUN = match_gnr, degree_vec =
input_degree)
C_match <- apply(new_C_deg, MARGIN = 2, FUN = match_gnr, degree_vec =
input_degree)
deriv_input <- all_input[, in_match]
deriv_input[is.na(deriv_input)] <- 0
deriv_C <- all_input[, C_match]
deriv_C[is.na(deriv_C)] <- 1
C <- deriv_C %*%
t(t(input_degree[i, input_degree[nrow(input_degree), ] == 0]) * C_coef)
elas <- deriv_input %*% t(t(input_degree[i, ]) * (gamma / gamma_denom)) + C
})
logomega <- big_Y - (as.matrix(pred) %*% C_coef)
omega <- exp(logomega)
productivity <- as.matrix(exp(logomega + errors))
ss_return <- list(productivity, degree, constant_gmm$niter, ctrl$maxit,
ctrl$reltol, convergence)
names(ss_return) <- c("productivity", "degree", "iterations", "maxit",
"reltol", "convergence")
average_elas <- lapply(elasticities, FUN = mean)
elasticities <- do.call(cbind, elasticities)
return_list <- list(elasticities, ss_return)
return(return_list)
}
constant_moments <- function(C_kl, data, big_Y_base, big_Y_lag, lag_data,
degree) {
w = big_Y_base - (data %*% C_kl)
w_1 = big_Y_lag - (lag_data %*% C_kl)
poly = sapply(2:degree, FUN = function(i) {
`^`(w_1, i)
})
markov = cbind(w_1, poly)
reg <- stats::lm(w ~ markov)
csi <- w - reg$fitted.values
moments <- apply(data, MARGIN = 2, FUN = function(i) {
sum(i * csi) / length(i)
})
return(moments)
}
match_gnr <- function(i, degree_vec) {
match_test <- apply(i == degree_vec, MARGIN = 2, FUN = prod)
col_index <- ifelse(length(which(match_test == 1)) != 0,
which(match_test == 1), NA)
}
industry_311 <- gnrprod(output = "RGO",
fixed = c("L", "K"),
flex = "RI",
share = exp(data$si),
id = "id",
time = "year",
data = data,
degree = 3,
markov_degree = 3)
View(industry_311)
