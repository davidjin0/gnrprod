"maxit" = share_reg$maxit,
"reltol" = share_reg$reltol,
"intial_step" = share_reg$initial_step,
"min_factor" = share_reg$min_factor,
"convergence" = share_reg$convergence
)
return(list(first_stage_results, first_stage_return))
}
gauss_newton_reg <- function(start, data, share, control) {
ctrl <- do.call("first_stage_control", control)
if (!missing(control)) {
control <- as.list(control)
ctrl[names(control)] <- control
}
iter <- 0
call_start <- start
inputs_1 = data.frame(rep(1, nrow(data)), data)
names(inputs_1)[1] <- "constant"
while (iter < ctrl$maxit) {
initial_pred <- evaluate_gnr(call_start, data)
X <- as.matrix(inputs_1 / initial_pred)
initial_errors <- as.matrix(cbind(share - log(initial_pred)))
initial_SSR <- t(initial_errors) %*% initial_errors
new_start <- call_start + (solve(t(X) %*% X) %*% t(X) %*% initial_errors)
new_pred <- evaluate_gnr(new_start, data)
suppressWarnings(new_errors <- cbind(share - log(new_pred)))
new_SSR <- t(new_errors) %*% new_errors
initial_step = ctrl$initial_step
min_factor = ctrl$min_factor
while ((is.na(new_SSR) || new_SSR > initial_SSR)
& initial_step >= min_factor) {
initial_step <- initial_step / 2
new_start <- call_start +
initial_step * (solve(t(X) %*% X) %*% t(X) %*% initial_errors)
new_pred <- evaluate_gnr(new_start, data)
suppressWarnings(new_errors <- cbind(share - log(new_pred)))
new_SSR = t(new_errors) %*% new_errors
}
conv_bool <- TRUE
for (i in 1:length(new_start)) {
if (initial_step * abs(new_start[i]) > ctrl$reltol *
(abs(new_start[i]) + 1e-3)) {
conv_bool <- FALSE
break
}
}
iter = iter + 1
if (conv_bool) {
return_list <- list(new_start, iter, new_SSR, ctrl$maxit, ctrl$reltol,
conv_bool, ctrl$initial_step, ctrl$min_factor)
names(return_list) <- c("share_reg_coef", "iterations", "SSR", "maxit",
"reltol", "convergence", "initial_step",
"min_factor")
return(return_list)
}
call_start = new_start
}
warning("share regression failed to converge")
return_list <- list(new_start, iter, new_SSR, ctrl$maxit, ctrl$reltol,
conv_bool, ctrl$initial_step, ctrl$min_factor)
names(return_list) <- c("share_reg_coef", "iterations", "SSR", "maxit",
"reltol", "convergence", "initial_step",
"min_factor")
return(return_list)
}
first_stage_control <- function(maxit = 100, reltol = 1e-5, initial_step = 100,
min_factor = 1e-5) {
if (maxit <= 0 || !is.numeric(maxit)) {
stop("maximum iteration count must be integer > 0")
}
if (reltol <= 0 || !is.numeric(reltol)) {
stop("relative tolerance must be numeric > 0")
}
if (initial_step <= 0 || !is.numeric(initial_step)) {
stop("initial_step must be numeric > 0")
}
if (min_factor < 0 || !is.numeric(min_factor)) {
stop("min_factor must be numeric >= 0")
}
list(maxit = maxit, reltol = reltol, initial_step = initial_step,
min_factor = min_factor)
}
evaluate_gnr <- function(start, data) {
matrix = as.matrix(cbind(rep(1, nrow(data)), data))
new_m = matrix %*% start
return(new_m)
}
extract.gnr <- function(object) object$point_estimates
coef.gnr <- function(object) object$avg_elasticity
print.gnr <- function(object, digits = max(3L, getOption("digits") - 3L)) {
cat("Call:\n")
cat("  output: ", deparse(object$call$output), "\n", sep = "")
cat("  fixed inputs: ", deparse(object$call$fixed), "\n", sep = " ")
cat("  flexible inputs: ", deparse(object$call$flex), "\n", sep = " ")
if (!is.null(object$call$data)) {
cat("  data: ", deparse(object$call$data), "\n", sep = "")
}
cat("\n")
cat("Average input elasticities:\n")
print(object$avg_elasticity, digits = digits)
cat("\n")
cat("First stage sum of squared residuals: ", object$first_stage$SSR)
invisible(object)
}
second_stage <- function(first_stage, degree, markov_degree, control) {
in_df <- data.frame(rbind(first_stage$input, first_stage$input_degree))
pred <- in_df[, in_df[nrow(in_df), ] == 0]
pred <- pred[-c((nrow(pred) -
(nrow(first_stage$input_degree) - 1)):(nrow(pred))), ]
flex <- in_df[, in_df[nrow(in_df), ] != 0]
flex <- flex[-c((nrow(flex) -
(nrow(first_stage$input_degree) - 1)):(nrow(flex))), ]
id <- data.frame(first_stage$id)
time <- data.frame(first_stage$time)
big_Y <- data.frame(first_stage$big_Y)
errors <- first_stage$errors
constant_reg <- stats::lm(as.matrix(big_Y) ~ as.matrix(pred))
coefficients <- as.matrix(stats::coef(constant_reg)[2:(ncol(pred) + 1)])
ss_df <- data.frame(cbind(id, time, pred, big_Y))
ss_df <- lag_gnr(ss_df)
pred_base <- as.matrix(ss_df[[1]])
big_Y_base <- pred_base[, ncol(pred_base)]
pred_base <- pred_base[, -c(ncol(pred_base))]
pred_lag <- as.matrix(ss_df[[2]])
big_Y_lag <- pred_lag[, ncol(pred_lag)]
pred_lag <- pred_lag[, -c(ncol(pred_lag))]
ctrl <- do.call("second_stage_control", control)
if (!missing(control)) {
control <- as.list(control)
ctrl[names(control)] <- control
}
constant_gmm <- pracma::gaussNewton(x0 = coefficients, data = pred_base,
Ffun = constant_moments,
big_Y_base = big_Y_base,
big_Y_lag = big_Y_lag,
lag_data = pred_lag,
markov_degree = markov_degree,
maxiter = ctrl$maxit,
tol = ctrl$reltol)
convergence <- ifelse(constant_gmm$niter >= ctrl$maxit, FALSE, TRUE)
C_coef <- constant_gmm$xs
input_degree <- first_stage$input_degree
all_input <- first_stage$input
gamma <- first_stage$gamma[-1, ]
gamma_denom <- first_stage$gamma_denom[-1, ]
elasticities <- lapply(1:(nrow(input_degree) - ncol(first_stage$flex_base)),
FUN = function(i) {
new_in_deg <- input_degree
new_in_deg[i, ] <- ifelse(new_in_deg[i, ] > 0,
new_in_deg[i, ] - 1,
new_in_deg[i, ])
new_C_deg <- new_in_deg[, new_in_deg[nrow(input_degree), ] == 0]
new_in_deg[nrow(new_in_deg), ] <- new_in_deg[nrow(new_in_deg), ] + 1
in_match <- apply(new_in_deg, MARGIN = 2, FUN = match_gnr, degree_vec =
input_degree)
C_match <- apply(new_C_deg, MARGIN = 2, FUN = match_gnr, degree_vec =
input_degree)
deriv_input <- all_input[, in_match]
deriv_input[is.na(deriv_input)] <- 0
deriv_C <- all_input[, C_match]
deriv_C[is.na(deriv_C)] <- 1
C <- deriv_C %*%
t(t(input_degree[i, input_degree[nrow(input_degree), ] == 0]) * C_coef)
elas <- deriv_input %*% t(t(input_degree[i, ]) * (gamma / gamma_denom)) + C
})
logomega <- big_Y - (as.matrix(pred) %*% C_coef)
omega <- exp(logomega)
productivity <- as.matrix(exp(logomega + errors))
ss_return <- list(productivity, markov_degree, constant_gmm$niter, ctrl$maxit,
ctrl$reltol, convergence)
names(ss_return) <- c("productivity", "markov_degree", "iterations", "maxit",
"reltol", "convergence")
average_elas <- lapply(elasticities, FUN = mean)
elasticities <- do.call(cbind, elasticities)
return_list <- list(elasticities, ss_return)
return(return_list)
}
constant_moments <- function(C_kl, data, big_Y_base, big_Y_lag, lag_data,
markov_degree) {
w = big_Y_base - (data %*% C_kl)
w_1 = big_Y_lag - (lag_data %*% C_kl)
poly = sapply(2:markov_degree, FUN = function(i) {
`^`(w_1, i)
})
markov = cbind(w_1, poly)
reg <- stats::lm(w ~ markov)
csi <- w - reg$fitted.values
moments <- apply(data, MARGIN = 2, FUN = function(i) {
sum(i * csi) / length(i)
})
return(moments)
}
match_gnr <- function(i, degree_vec) {
match_test <- apply(i == degree_vec, MARGIN = 2, FUN = prod)
col_index <- ifelse(length(which(match_test == 1)) != 0,
which(match_test == 1), NA)
}
second_stage_control <- function(maxit = 100, reltol = 1e-8) {
if (maxit <= 0 || !is.numeric(maxit)) {
stop("maximum iteration count must be integer > 0")
}
if (reltol <= 0 || !is.numeric(reltol)) {
stop("relative tolerance must be numeric > 0")
}
list(maxit = maxit, reltol = reltol)
}
lag_gnr <- function(unsorted) {
unique_ids <- unique(unsorted$first_stage.id)
lag_indic <- 3:ncol(unsorted)
lag_2 <- function(i) {
i_df <- unsorted[unsorted$first_stage.id == i, ]
i_df <- i_df[order(i_df$first_stage.time), ]
lag_1_df <- data.frame(matrix(NA, nrow = 1, ncol = length(lag_indic)))
colnames(lag_1_df)[1:ncol(lag_1_df)] = colnames(i_df)[lag_indic]
lag_1_df <- rbind(lag_1_df, i_df[, lag_indic])
lag_1_df <- lag_1_df[-nrow(lag_1_df), ]
i_df <- cbind(i_df, lag_1_df)
}
lagged_list <- lapply(unique_ids, FUN = lag_2)
lagged_df <- do.call(rbind, lagged_list)
lagged_df <- stats::na.omit(lagged_df)
lag_base_list <- list(lagged_df[, 3:ncol(unsorted)],
lagged_df[, (ncol(unsorted) + 1):ncol(lagged_df)])
return(lag_base_list)
}
test <- extract(industry_311)
View(industry_311)
extract.gnr <- function(object) object$point_estimates
coef.gnr <- function(object) object$avg_elasticity
print.gnr <- function(object, digits = max(3L, getOption("digits") - 3L)) {
cat("Call:\n")
cat("  output: ", deparse(object$call$output), "\n", sep = "")
cat("  fixed inputs: ", deparse(object$call$fixed), "\n", sep = " ")
cat("  flexible inputs: ", deparse(object$call$flex), "\n", sep = " ")
if (!is.null(object$call$data)) {
cat("  data: ", deparse(object$call$data), "\n", sep = "")
}
cat("\n")
cat("Average input elasticities:\n")
print(object$avg_elasticity, digits = digits)
cat("\n")
cat("First stage sum of squared residuals: ", object$first_stage$SSR)
invisible(object)
}
test <- extract(industry_311)
test <- extract.gnr(industry_311)
coef(industry_311)
industry_311
extract(industry_311)
?extract
library(sloop)
ftype(extract)
coef(industry_311)
View(industry_311)
industry_311 <- gnrprod(output = "RGO",
fixed = c("L", "K"),
flex = "RI",
share = exp(data_311$si),
id = "id",
time = "year",
data = data_311,
degree = 3,
markov_degree = 3,
firstStageOnly = FALSE)
View(industry_311)
industry_311[["point_estimates"]][["estimates"]]
str(industry_311$point_estimates$estimates)
is.data.frame(industry_311$point_estimates$estimates)
#' Estimate the nonparametric model in two stages: the share regression and instrumental variable estimation
#'
#' @param output name (character) of variable of level gross output or a numeric vector/dataframe/matrix
#' @param fixed name (character or character vector) of variables of level fixed inputs or a numeric vector/dataframe/matrix
#' @param flex name (character) of variable of level flexible input or a numeric vector/dataframe/matrix
#' @param share name (character) of variable of level intermediate input's revenue share or a numeric vector/dataframe/matrix
#' @param in_price optional name (character) of variable of common flexible input price or a numeric vector/dataframe/matrix
#' @param out_price optional name (character) of variable of common output price or a numeric vector/dataframe/matrix
#' @param id name (character) of variable of firm id or a numeric vector/dataframe/matrix
#' @param time name (character) of variable of time or a numeric vector/dataframe/matrix
#' @param data dataframe containing all variables with names specified by arguments above (left empty if arguments above are vector/dataframe/matrix)
#' @param degree degree of share regression polynomial
#' @param markov_degree degree of Markovian process for persistent productivity
#' @param firstStageOnly boolean for whether return is only first stage results
#' @param fs_control list of convergence parameters for first stage
#' @param ss_control list of convergence parameters for second stage
#' @export
gnrprod <- function(output,
fixed,
flex,
share,
in_price = NULL,
out_price = NULL,
id,
time,
data,
degree = 2,
markov_degree = 2,
firstStageOnly = FALSE,
fs_control = list(),
ss_control = list()
) {
cl <- match.call()
if (is.character(output)) {
y <- as.matrix(log(data[, output]))
output_name <- output
} else {
y <- as.matrix(log(output))
output_name <- colnames(output)
if (is.null(output_name)) {
output_name <- deparse(substitute(output))
}
}
if (is.character(fixed)) {
fixed_input <- as.matrix(log(data[, fixed]))
fixed_name <- fixed
} else {
fixed_input <- as.matrix(log(fixed))
fixed_name <- colnames(fixed)
if (is.null(fixed_name)) {
fixed_name <- paste0(deparse(substitute(fixed)), 1L:ncol(fixed))
}
}
if (is.character(flex)) {
flex_input <- as.matrix(log(data[, flex]))
flex_name <- flex
} else {
flex_input <- as.matrix(log(flex))
flex_name <- colnames(flex)
if (is.null(flex_name)) {
flex_name <- deparse(substitute(flex))
}
}
if (is.character(id)) {
idm <- as.matrix(data[, id])
id_name <- id
} else {
idm <- as.matrix(id)
id_name <- colnames(id)
if (is.null(id_name)) {
id_name <- deparse(substitute(id))
}
}
if (is.character(time)) {
timem <- as.matrix(data[, time])
time_name <- time
} else {
timem <- as.matrix(timem)
time_name <- colnames(time)
if (is.null(time_name)) {
time_name <- deparse(substitute(time))
}
}
if (!missing(share) && is.character(share)) {
sharem <- as.matrix(log(data[, share]))
share_name <- share
} else if (!missing(share) && !is.character(share)) {
sharem <- as.matrix(log(share))
share_name <- colnames(share)
if (is.null(share_name)) {
share_name <- deparse(substitute(share))
}
} else if (!missing(in_price) && !missing(out_price)) {
if (is.character(in_price)) {
in_pricem <- as.matrix(data[, in_price])
} else {
in_pricem <- as.matrix(in_price)
}
if (is.character(out_price)) {
out_pricem <- as.matrix(data[, out_price])
} else {
out_pricem <- as.matrix(out_price)
}
sharem = as.matrix(log((in_price * flex_input) / (out_price * y)))
share_name = "share"
} else {
stop("must specify either share or intermediate-input price and output price")
}
complete_obs <- stats::complete.cases(cbind(y, fixed_input, flex_input, idm,
timem, sharem))
y <- y[complete_obs]
fixed_input <- data.frame(fixed_input[complete_obs, ])
flex_input <- data.frame(flex_input[complete_obs])
idm <- idm[complete_obs]
timem <- timem[complete_obs]
sharem <- sharem[complete_obs]
all_input = as.matrix(cbind(fixed_input, flex_input))
poly_input = as.matrix(stats::poly(all_input, degree = degree, raw = TRUE))
input_degrees <- sapply(colnames(poly_input), FUN = function(x) {
a <- data.frame(base::strsplit(x, split = "[.]")[[1]])
})
input_degrees <- do.call(cbind, input_degrees)
inputs = list("poly_input" = poly_input,
"input_degrees" = input_degrees,
"flex_in" = flex_input)
first_stage_list <- first_stage(output = y,
input = inputs,
share = sharem,
id = idm,
time = timem,
fs_control = fs_control,
degree = degree)
fs_results <- first_stage_list[[1]]
fs_return <- first_stage_list[[2]]
if (firstStageOnly) {
return(fs_return)
}
second_stage_list <- second_stage(first_stage = fs_results, degree = degree,
markov_degree = markov_degree,
control = ss_control)
ss_return <- second_stage_list[[2]]
pred_elas <- second_stage_list[[1]]
flex_elas <- fs_results$flex_in_elasticity
elas <- data.frame(cbind(pred_elas, flex_elas))
input_names <- c(fixed_name, flex_name)
input_names <- paste(input_names, "elasticity", sep = "_")
colnames(elas) <- input_names
return_df <- data.frame(cbind(y, fixed_input, flex_input, idm, timem, sharem))
colnames(return_df) <- c(output_name, fixed_name, flex_name, id_name,
time_name, share_name)
point_estimates <- list("estimates" = elas, "data" = return_df)
return_average_elas <- apply(elas, MARGIN = 2, FUN = mean)
names(return_average_elas) <- paste(input_names, "avg", sep = "_")
gnr_out <- list(return_average_elas, point_estimates, fs_return, ss_return, cl)
names(gnr_out) <- c("avg_elasticity", "point_estimates", "first_stage",
"second_stage", "call")
class(gnr_out) <- "gnr"
return(gnr_out)
}
industry_311 <- gnrprod(output = "RGO",
fixed = c("L", "K"),
flex = "RI",
share = exp(data_311$si),
id = "id",
time = "year",
data = data_311,
degree = 3,
markov_degree = 3,
firstStageOnly = FALSE)
View(industry_311)
?profiel
?profile
?residuals
?sumilate
?simulate
ftype(simulate)
?fitted
?df.residual
?extract
View(industry_311)
library(usethis)
use_data_raw()
?read.dta
?read_dta
columbian <- read_dta('D:/Penn 2021-2022/Research/Amit Gandhi/data_col.dta')
View(columbian)
library(tidyverse)
columbian[, c(1:2, 3:8, 11:18, 20:22)] = NULL
View(columbian)
columbian <- read_dta('D:/Penn 2021-2022/Research/Amit Gandhi/data_col.dta')
columbian[, c(1:2, 4:8, 11:18, 20:22)] = NULL
View(columbian)
columbian$si = exp(si)
columbian$si = exp(columbian$si)
?use_data
usethis::use_data(columbian, name = "columbian")
usethis::use_data(columbian, gnrprod)
usethis::use_data(columbian)
usethis::use_data(columbian)
usethis::use_data_raw()
columbian <- na.omit(columbian)
library(tidyverse)
columbian <- read_dta('D:/Penn 2021-2022/Research/Amit Gandhi/data_col.dta')
columbian[, c(1:2, 4:8, 11:18, 20:22)] = NULL
columbian$si = exp(columbian$si)
columbian <- na.omit(columbian)
usethis::use_data(columbian)
library(tidyverse)
library(haven)
columbian <- read_dta('D:/Penn 2021-2022/Research/Amit Gandhi/data_col.dta')
columbian[, c(1:2, 4:8, 11:18, 20:22)] = NULL
columbian$si = exp(columbian$si)
columbian <- na.omit(columbian)
usethis::use_data(columbian)
library(tidyverse)
library(haven)
columbian <- read_dta('D:/Penn 2021-2022/Research/Amit Gandhi/data_col.dta')
columbian[, c(1:2, 4:8, 11:18, 20:22)] = NULL
columbian$si = exp(columbian$si)
columbian <- na.omit(columbian)
usethis::use_data(columbian, overwrite = TRUE)
beans <- colombian
beans <- data(colombian)
library(tidyverse)
library(haven)
colombian <- read_dta('data_col.dta')
colombian[, c(1:2, 4:8, 11:18, 20:22)] = NULL
colombian$si = exp(colombian$si)
colombian <- na.omit(colombian)
usethis::use_data(colombian, overwrite = TRUE)
colombian <- read_dta('D:/Penn 2021-2022/Research/Amit Gandhi/data_col.dta')
colombian[, c(1:2, 4:8, 11:18, 20:22)] = NULL
colombian$si = exp(colombian$si)
colombian <- na.omit(colombian)
usethis::use_data(colombian, overwrite = TRUE)
View(colombian)
library(tidyverse)
library(haven)
colombian <- read_dta('data_col.dta')
colombian[, c(1:2, 4:8, 11:18, 20:22)] = NULL
colombian$si <- exp(colombian$si)
names(colombian)[1] <- "share"
colombian <- na.omit(colombian)
usethis::use_data(colombian, overwrite = TRUE)
